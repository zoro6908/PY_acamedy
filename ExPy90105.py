# ExPy9xxxx 파이썬 개인 연습
# pandas
# https://dandyrilla.github.io/2017-08-12/pandas-10min/
# https://pandas.pydata.org/docs/user_guide/basics.html

# 3. 데이터 선택하기 (Selection)

import pandas as pd
import numpy as np

dates = pd.date_range('20130101', periods=6)
df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD'))

# # [] 슬라이싱 기능을 이용하는 방법입니다. 특정 ‘컬럼’의 값들만 가져오고 싶다면 df['A']와 같은 형태로 입력합니다.
# print(df['A'])
# # 2013-01-01   -0.622405
# # 2013-01-02   -0.471670
# # 2013-01-03   -1.086029
# # 2013-01-04   -1.241927
# # 2013-01-05    0.902491
# # 2013-01-06   -0.919539
# # Freq: D, Name: A, dtype: float64
#
# # 이는 df.A와 동일합니다. 리턴되는 값은 Series 의 자료구조를 갖고 있습니다.
# print(type(df['A']))
# # <class 'pandas.core.series.Series'>

# 특정 ‘행 범위’를 가져오고 싶다면 다음과 같이 리스트를 슬라이싱 할 때와 같이 []를 이용할 수 있습니다.
# df[0:3] 라고 하면 0, 1, 2번째 행을 가져옵니다(데이터프레임의 첫번째 행을 0번째 행이라고 가정).
# [0:3] 이라고 입력했지만 3번째 행을 가져오지 않음에 유의합니다.
# 또 다른 방법으로 df['20130102':'20130104'] 인덱스명을 직접 넣어서 해당하는 ‘행 범위’를 가져올 수도 있습니다.
# 이 때에는 숫자를 이용하여 슬라이싱 할 때와 달리 처음과 끝의 행이 모두 포함된 결과를 가져옵니다.

# ## 맨 처음 3개의 행을 가져옵니다.
# print(df[0:3])
# #                    A         B         C         D
# # 2013-01-01  0.646800  0.054225 -0.297986  1.022080
# # 2013-01-02 -1.456501 -0.220350 -0.360687 -1.723273
# # 2013-01-03 -0.333423  1.510204  0.577429 -0.259033
#
# ## 인덱스명에 해당하는 값들을 가져옵니다. df['20130102'] 라고 하면 KeyError 가 발생
# print(df['20130102':'20130104'])
# #                    A         B         C         D
# # 2013-01-02  0.728100  0.536227 -1.111738  0.130831
# # 2013-01-03 -0.420335 -0.650166  0.942769 -0.941994
# # 2013-01-04 -0.319030  0.572078  0.350163 -0.878851

# # 라벨의 이름을 이용하여 선택할 수 있는 .loc를 이용할 수도 있습니다.
# print(df.loc[dates[0]])
# # A   -0.226230
# # B    0.635450
# # C   -0.729703
# # D    0.686535
# # Name: 2013-01-01 00:00:00, dtype: float64
#
# # 컬럼 ‘A’와 컬럼 ‘B’에 대한 모든 값 가져오기.
# print(df.loc[:,['A','B']])
# #                    A         B
# # 2013-01-01  1.456068  0.571253
# # 2013-01-02  1.290939 -0.175377
# # 2013-01-03 -0.679648 -0.454107
# # 2013-01-04 -0.228368  0.249913
# # 2013-01-05 -0.043553 -0.091948
# # 2013-01-06 -0.455763 -1.544319
#
# print(df.loc['20130103':'20130104', ['A','B']])
# #                    A         B
# # 2013-01-03  0.939424 -0.426377
# # 2013-01-04  0.287636 -0.428619

# # 특정 인덱스 값의 컬럼 ‘A’, ‘B’ 값을 가져오기.
# print(df.loc[dates[0], ['A','B']])
# # A    0.150933
# # B   -1.221116
# # Name: 2013-01-01 00:00:00, dtype: float64

# 특정 인덱스 값과 특정 컬럼에 있는 값 가져오기. 이는 .at을 이용할 수도 있습니다.
# print(df.loc[dates[0],'A'])
# # 0.1712091286303978
#
# print(df.at[dates[0], 'A'])
# # -0.41039291616845186

# 위치를 이용하여 선택하기: .iloc
# print(df.iloc[3])
# # A    0.991083
# # B    0.142976
# # C   -0.215848
# # D   -0.603490
# # Name: 2013-01-04 00:00:00, dtype: float64

# print(df.iloc[3:5,0:2])
# #                    A         B
# # 2013-01-04 -0.746688 -0.047989
# # 2013-01-05  0.599468  1.400715

# print(df.iloc[[1,2,4],[0,2]])
# #                    A         C
# # 2013-01-02  1.082963 -0.077395
# # 2013-01-03 -0.620082 -1.171484
# # 2013-01-05  1.259872  0.014602

# # 명시적으로 행이나 열 선택 인자에 : 슬라이스를 전달하면 다음과 같이 행 또는 열 전체를 가져올 수도 있습니다.
# print(df.iloc[1:3,:])
# #                    A         B         C         D
# # 2013-01-02 -0.575341  0.407850 -0.290039 -1.506642
# # 2013-01-03 -0.505277  1.258355  1.434443 -0.960817
#
# print(df.iloc[:,1:3])
# #                    B         C
# # 2013-01-01  0.802601  0.736965
# # 2013-01-02 -1.569273 -0.554630
# # 2013-01-03  1.454423 -0.228846
# # 2013-01-04 -1.507756  2.339043
# # 2013-01-05 -0.766693  1.317954
# # 2013-01-06  1.531454 -0.043966

# # 값 하나를 선택하기 위해서는 특정 행과 열을 지정하는 방식으로 하면 됩니다. 아래의 두 방법 모두 동일한 방법입니다.
# print(df.iloc[1,1])
# # 0.23904800560416928
# print(df.iat[1,1])
# # 0.23904800560416928

# 특정한 열의 값들을 기준으로 조건을 만들어 해당 조건에 만족하는 행들만 선택할 수 있는 방법
# print(df.A>0)
# # 2013-01-01     True
# # 2013-01-02    False
# # 2013-01-03     True
# # 2013-01-04    False
# # 2013-01-05     True
# # 2013-01-06     True
# # Freq: D, Name: A, dtype: bool
# print(df[df.A>0])
# #                    A         B         C         D
# # 2013-01-01  1.440414 -0.962320  2.038549  2.091189
# # 2013-01-03  1.448158  0.548901  2.146251 -0.413474
# # 2013-01-05  0.262432 -0.373743  1.276423 -1.641956
# # 2013-01-06  1.224874  0.226891  2.132016  1.061969

# print(df>0)
# #                 A      B      C      D
# # 2013-01-01  False   True  False  False
# # 2013-01-02  False  False   True  False
# # 2013-01-03  False   True  False   True
# # 2013-01-04   True   True  False  False
# # 2013-01-05   True   True  False  False
# # 2013-01-06  False   True  False   True
# print(df[df>0])
# # 데이터 프레임의 전체 모양은 유지된 채로 조건에 맞는 값들만 그대로 보여지고 나머지 값들은 추후에 배울 결측치(missing value)로 나타남
# # 값이 양수인 것들만 보여지고 나머지 값들(0 혹은 음수)은 NaN
# #                    A         B         C         D
# # 2013-01-01       NaN  0.966256       NaN       NaN
# # 2013-01-02       NaN       NaN  0.374279       NaN
# # 2013-01-03       NaN  0.598950       NaN  0.161595
# # 2013-01-04  0.524629  0.318228       NaN       NaN
# # 2013-01-05  0.265116  0.155561       NaN       NaN
# # 2013-01-06       NaN  0.922587       NaN  0.669944

# # 필터링을 해야 하는 경우에 사용할 수 있는 isin()이라는 메소드도 제공
# df2 = df.copy()
# df2['E'] = ['one', 'one','two','three','four','three']
#
# print(df2)
# #                   A         B         C         D      E
# # 2013-01-01  0.396631 -0.780633 -0.783240  1.062811    one
# # 2013-01-02  0.089327  0.310786 -1.122799 -1.670345    one
# # 2013-01-03 -0.733548  0.253965 -1.404142 -0.939605    two
# # 2013-01-04 -0.503380 -1.247824 -1.036754 -0.428339  three
# # 2013-01-05 -1.004532 -1.324982  0.296792  2.269216   four
# # 2013-01-06  0.921622  0.421334 -0.108614  0.097746  three
#
# print(df2['E'].isin(['two', 'four']))
# # 2013-01-01    False
# # 2013-01-02    False
# # 2013-01-03     True
# # 2013-01-04    False
# # 2013-01-05     True
# # 2013-01-06    False
# # Freq: D, Name: E, dtype: bool
#
# print(df2[df2['E'].isin(['two', 'four'])])
# #                    A         B         C         D     E
# # 2013-01-03 -0.733548  0.253965 -1.404142 -0.939605   two
# # 2013-01-05 -1.004532 -1.324982  0.296792  2.269216  four

# 데이터 변경하기
# s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range('20130102', periods=6))
# print(s1)
# # 2013-01-02    1
# # 2013-01-03    2
# # 2013-01-04    3
# # 2013-01-05    4
# # 2013-01-06    5
# # 2013-01-07    6
# # Freq: D, dtype: int64
#
# df['F'] = s1                            # F열을 Series를 이용하여 추가
# df.at[dates[0],'A'] = 0                 # index 0의 'A'열의 값을 0 으로 변경
# df.iat[0,1] = 0                         # index [0, 1] 값을 0으로 변경
# df.loc[:, 'D'] = np.array([5]*len(df))  # array를 만들어 D열에 5값을 len(df) = 6에 주입
# print(df)
# #                    A         B         C  D    F
# # 2013-01-01  0.000000  0.000000  0.700860  5  NaN
# # 2013-01-02 -0.697803 -0.628531  0.187956  5  1.0
# # 2013-01-03 -0.068805 -0.121323 -1.021751  5  2.0
# # 2013-01-04 -2.469515 -0.116333  1.043963  5  3.0
# # 2013-01-05  1.801254  0.287210  0.223004  5  4.0
# # 2013-01-06 -0.342228 -0.764188  0.591941  5  5.0

# df2 = df.copy()
# print(df2)
# #                    A         B         C         D
# # 2013-01-01 -0.304830 -0.861800 -0.251903  0.710293
# # 2013-01-02 -0.105423  0.136826 -0.937718  0.630215
# # 2013-01-03 -0.142228  2.102884 -1.945554 -0.463908
# # 2013-01-04 -1.339221 -1.278999 -1.534540  0.993090
# # 2013-01-05  0.930455  0.661903  0.345161 -0.433642
# # 2013-01-06 -0.479729  0.219738  0.283259 -2.139518
# print(df2>0)                 # 양수인 값들 표시
# #                 A      B      C      D
# # 2013-01-01  False  False  False   True
# # 2013-01-02  False   True  False   True
# # 2013-01-03  False   True  False  False
# # 2013-01-04  False  False  False   True
# # 2013-01-05   True   True   True  False
# # 2013-01-06  False   True   True  False
#
# df2[df2 > 0] = -df2          # 양수 값을 모두 음수로 변경
# print(df2)
#                    A         B         C         D
# 2013-01-01 -0.304830 -0.861800 -0.251903 -0.710293
# 2013-01-02 -0.105423 -0.136826 -0.937718 -0.630215
# 2013-01-03 -0.142228 -2.102884 -1.945554 -0.463908
# 2013-01-04 -1.339221 -1.278999 -1.534540 -0.993090
# 2013-01-05 -0.930455 -0.661903 -0.345161 -0.433642
# 2013-01-06 -0.479729 -0.219738 -0.283259 -2.139518

# 4. 결측치 (Missing Data)
# 측정되지 못하여 비어있는 데이터를 ‘결측치’라고 합니다.
# pandas 에서는 결측치를 np.nan 으로 나타냅니다.
# pandas 에서는 결측치를 기본적으로 연산에서 제외

# 재인덱싱(reindex)은 해당 축에 대하여 인덱스를 변경/추가/삭제
df1 = df.reindex(index=dates[0:4], columns=list(df.columns)+['E'])
df1.loc[dates[0]:dates[1], 'E'] = 1

print(df1)
#                    A         B         C         D    E
# 2013-01-01 -0.432026  0.199996  1.823712  1.888767  1.0
# 2013-01-02  2.048342  0.068711  2.036414  0.069207  1.0
# 2013-01-03  0.997898 -2.572760  0.416893  0.322442  NaN
# 2013-01-04 -1.591356  0.561363 -0.734683  0.350188  NaN

# 결측치가 하나라도 존재하는 행들을 버리고 싶을 때는 dropna() 메소드를 이용
print(df1.dropna(how='any'))
#                    A         B         C         D    E
# 2013-01-01 -0.432026  0.199996  1.823712  1.888767  1.0
# 2013-01-02  2.048342  0.068711  2.036414  0.069207  1.0

# 결측치가 있는 부분을 다른 값으로 채우고 싶다면 fillna() 메소드를 이용
print(df1.fillna(value=5))
#                    A         B         C         D    E
# 2013-01-01 -0.432026  0.199996  1.823712  1.888767  1.0
# 2013-01-02  2.048342  0.068711  2.036414  0.069207  1.0
# 2013-01-03  0.997898 -2.572760  0.416893  0.322442  5.0
# 2013-01-04 -1.591356  0.561363 -0.734683  0.350188  5.0

# 해당 값이 결측치인지 아닌지의 여부를 알고싶다면 isna() 메소드를 이용 결측치이면 True, 값이 있다면 False
print(df1.isna())
#                 A      B      C      D      E
# 2013-01-01  False  False  False  False  False
# 2013-01-02  False  False  False  False  False
# 2013-01-03  False  False  False  False   True
# 2013-01-04  False  False  False  False   True